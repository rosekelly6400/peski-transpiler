// union type
%union {
	struct decl *decl;
	struct stmt *stmt;
	struct expr *expr;
	struct type *type;
	struct param_list *param_list;
	char *name;
};

//which member of union to use
%type <decl> program decl_list decl var_assgn
%type <stmt> stmt stmt_list if_stmt_list while_stmt_list
%type <expr> expr name opt_fcall_list fcall_list expr_bcomp_a expr_icomp expr_as expr_mmd expr_negate expr_e expr_par factor
%type <param_list> opt_param_list param_list param
%type <type> type


/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_EOF
%token TOKEN_WHILEA
%token TOKEN_WHILEB
%token TOKEN_WHILE_END
%token TOKEN_PLUS
%token TOKEN_IDENT
%token TOKEN_EXPONENT
%token TOKEN_ERROR
%token TOKEN_MINUS
%token TOKEN_MUL
%token TOKEN_DIV
%token TOKEN_STRING
%token TOKEN_CHAR
%token TOKEN_NUMBER
%token TOKEN_FALSE
%token TOKEN_DECREMENT
%token TOKEN_INCREMENT
%token TOKEN_ASSIGN
%token TOKEN_EQUALITY
%token TOKEN_HEART
%token TOKEN_LT
%token TOKEN_LE
%token TOKEN_GT
%token TOKEN_GE
%token TOKEN_NOTEQUALS
%token TOKEN_NEGATION
%token TOKEN_MODULO
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_LEFTPARAN
%token TOKEN_RIGHTPARAN
%token TOKEN_LEFTBRACKET
%token TOKEN_RIGHTBRACKET
%token TOKEN_CCOMMENT
%token TOKEN_CPPCOMMENT
%token TOKEN_TRUE
%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHARKEY
%token TOKEN_ELSE
%token TOKEN_FOR
%token TOKEN_FUNCTIONA
%token TOKEN_FUNCTION_MAIN
%token TOKEN_FUNCTIONB
%token TOKEN_FUNCTIONC
%token TOKEN_FUNCTION_END
%token TOKEN_IF
%token TOKEN_IF_END
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRINGKEY
%token TOKEN_VOID
%token TOKEN_SEMICOLON
%token TOKEN_COLON
%token TOKEN_TILDE
%token TOKEN_LEFTCURLYBRACE
%token TOKEN_RIGHTCURLYBRACE
%token TOKEN_COMMA

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "decl.h"
#include "expr.h"
#include "type.h"
#include "stmt.h"
#include "param_list.h"
#include <ctype.h>
#include <string.h>

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

struct decl * parser_result = 0;

%}

%%

/* Here is the grammar: program is the start symbol. */

program : decl_list TOKEN_HEART TOKEN_HEART TOKEN_HEART {parser_result = $1; return 0;}
	;

decl_list: /* empty */ { $$ = 0; }
	| decl decl_list { $$ = $1; $1->next = $2; } 
	;

decl :	 var_assgn {  $$ = $1; }
	| name TOKEN_FUNCTIONA type TOKEN_FUNCTIONB opt_param_list TOKEN_FUNCTIONC stmt_list TOKEN_FUNCTION_END { $$ = decl_create( $1->name, type_create(TYPE_FUNCTION,$3, $5), 0, $7, 0 ); }
    | TOKEN_FUNCTION_MAIN stmt_list TOKEN_FUNCTION_END { $$ = decl_create( "main", type_create(TYPE_FUNCTION, type_create( TYPE_INTEGER, 0, 0 ), 0), 0, $2, 0 ); }
	;

opt_param_list : /* empty */ { $$ = 0; }
	| param_list { $$ = $1; }
	;

param_list : param { $$ = $1; }
	| param TOKEN_COMMA param_list { $$ = $1; $1->next = $3; }
	;


param : type TOKEN_COLON name { $$ = param_list_create( $3->name, $1, 0 ); } 
	;

stmt_list : /*empty*/ { $$ = 0; }
	| stmt stmt_list { $$ = $1; $1->next = $2; }
	;

stmt 	: TOKEN_LEFTBRACKET expr TOKEN_RIGHTBRACKET TOKEN_RETURN { $$ = stmt_create( STMT_RETURN, 0, 0, $2, 0, 0, 0, 0 ); }
	| TOKEN_PRINT TOKEN_LEFTPARAN expr TOKEN_RIGHTPARAN { $$ = stmt_create( STMT_PRINT, 0, 0, $3, 0, 0, 0, 0 ); }
	| TOKEN_WHILEA expr TOKEN_WHILEB while_stmt_list TOKEN_WHILE_END { $$ = stmt_create( STMT_WHILE, 0, 0, $2, 0, $4, 0, 0 ); }
	| TOKEN_IF expr if_stmt_list TOKEN_IF_END { $$ = stmt_create(STMT_IF_ELSE,0,0,$2,0,$3,0,0); }
	| TOKEN_IF expr if_stmt_list TOKEN_ELSE if_stmt_list TOKEN_IF_END { $$ = stmt_create(STMT_IF_ELSE,0,0,$2,0,$3,$5, 0); }
	| name TOKEN_HEART opt_fcall_list TOKEN_HEART { $$ = stmt_create( STMT_EXPR, 0, 0, expr_create( EXPR_FCALL, $1, $3), 0, 0, 0, 0 ); }
	| name TOKEN_INCREMENT { $$ = stmt_create( STMT_EXPR, 0, 0, expr_create( EXPR_INCREMENT, $1, 0 ), 0, 0, 0, 0 ); }
	| name TOKEN_DECREMENT { $$ = stmt_create( STMT_EXPR, 0, 0, expr_create( EXPR_DECREMENT, $1, 0 ), 0, 0, 0, 0 ); }
	| name  TOKEN_ASSIGN expr { $$ = stmt_create( STMT_EXPR, 0, 0, expr_create( EXPR_ASSIGN, $1, $3 ), 0, 0, 0, 0 ); }
	| var_assgn { $$ = stmt_create( STMT_DECL, $1, 0, 0, 0, 0, 0, 0 );}
	;

opt_fcall_list: /* empty */  { $$ = 0; }
	| fcall_list { $$ = $1; }
	;

fcall_list: expr { $$ = $1; }
	| expr TOKEN_COMMA fcall_list { $$ = expr_create( EXPR_ARG, $1, $3); }
	;

if_stmt_list : /*empty*/ { $$ = 0; }
	| TOKEN_LEFTCURLYBRACE stmt TOKEN_RIGHTCURLYBRACE if_stmt_list { $$ = $2; $2->next = $4; }
	| TOKEN_LEFTCURLYBRACE TOKEN_RIGHTCURLYBRACE if_stmt_list { $$ = $3; }
	;

while_stmt_list: /*empty*/ { $$ = 0; }
	| TOKEN_TILDE stmt TOKEN_TILDE while_stmt_list { $$ = $2; $2->next = $4; }
	| TOKEN_TILDE TOKEN_TILDE while_stmt_list { $$ = $3; }
	;

var_assgn : type TOKEN_COLON name TOKEN_ASSIGN expr { $$ = decl_create($3->name,$1,$5,0,0); }
	| type TOKEN_COLON name { $$ = decl_create($3->name,$1,0,0,0); }
	;

type: TOKEN_CHARKEY { $$ = type_create( TYPE_CHARACTER, 0, 0 ); }
	| TOKEN_BOOLEAN { $$ = type_create( TYPE_BOOLEAN, 0, 0 ); }
	| TOKEN_INTEGER { $$ = type_create( TYPE_INTEGER, 0, 0 ); }
	| TOKEN_STRINGKEY { $$ = type_create( TYPE_STRING, 0, 0 ); }
	| TOKEN_VOID { $$ = type_create( TYPE_VOID, 0, 0 ); }
	;

expr: expr TOKEN_OR expr_bcomp_a { $$ = expr_create( EXPR_OR, $1, $3 ); }
	| expr_bcomp_a { $$ = $1; }
	;

expr_bcomp_a: expr_bcomp_a TOKEN_AND expr_icomp { $$ = expr_create( EXPR_AND, $1, $3 ); }
	| expr_icomp { $$ = $1; }
	;

expr_icomp:  expr_icomp TOKEN_GT expr_as { $$ = expr_create( EXPR_GT, $1, $3 ); }
	| expr_icomp TOKEN_LT expr_as { $$ = expr_create( EXPR_LT, $1, $3 ); }
	| expr_icomp TOKEN_GE expr_as { $$ = expr_create( EXPR_GE, $1, $3 ); }
	| expr_icomp TOKEN_LE expr_as { $$ = expr_create( EXPR_LE, $1, $3 ); }
	| expr_icomp TOKEN_NOTEQUALS expr_as { $$ = expr_create( EXPR_NOT_EQUALS, $1, $3 ); }
	| expr_icomp TOKEN_EQUALITY expr_as { $$ = expr_create( EXPR_EQUALS, $1, $3 ); }
	| expr_as { $$ = $1; }
	;


expr_as : expr_as TOKEN_PLUS expr_mmd { $$ = expr_create( EXPR_ADD, $1, $3 ); }
	| expr_as TOKEN_MINUS expr_mmd { $$ = expr_create( EXPR_SUB, $1, $3 ); }
	| expr_mmd { $$ = $1; }
	;

expr_mmd: expr_mmd TOKEN_MUL expr_e { $$ = expr_create( EXPR_MUL, $1, $3 ); }
	| expr_mmd TOKEN_DIV expr_e { $$ = expr_create( EXPR_DIV, $1, $3 ); }
	| expr_mmd TOKEN_MODULO expr_e { $$ = expr_create( EXPR_MOD, $1, $3 ); }
	| expr_e { $$ = $1; }
	;

expr_e : expr_e TOKEN_EXPONENT expr_negate { $$ = expr_create( EXPR_EXPONENT, $1, $3 ); }
	| expr_negate { $$ = $1; }
	;

expr_negate: TOKEN_MINUS expr_par { $$ = expr_create( EXPR_NOT, 0, $2); }
	| TOKEN_NEGATION expr_par { $$ = $2; }
	| expr_par { $$ = $1; }
	;

expr_par : TOKEN_LEFTPARAN expr TOKEN_RIGHTPARAN { $$ = expr_create( EXPR_BLOCK, 0, $2 ); }
	| factor { $$ = $1; }
	;

factor  : TOKEN_NUMBER { $$ = expr_create_integer_literal(atoi(yytext)); }
	| name { $$ = $1; }
	| TOKEN_CHAR { $$ = expr_create_char_literal(yytext); }
	| TOKEN_STRING { $$ = expr_create_string_literal(yytext); }
	| TOKEN_TRUE { $$ = expr_create_boolean_literal(1) ; }
	| TOKEN_FALSE { $$ = expr_create_boolean_literal(0) ; }
	;

name : TOKEN_IDENT { $$ = expr_create_name(yytext); }
	;


%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	return 0;
}
